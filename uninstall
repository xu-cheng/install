#!/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/bin/ruby

require "optparse"
require "pathname"

# Default options
options = {
  :force => false,
  :quiet => false,
  :dry_run => false,
  :skip_cache_log => false,
}

module Tty extend self
  def blue; bold 34; end
  def white; bold 39; end
  def red; underline 31; end
  def reset; escape 0; end
  def bold n; escape "1;#{n}" end
  def underline n; escape "4;#{n}" end
  def escape n; "\033[#{n}m" if STDOUT.tty? end
end

class Array
  def shell_s
    cp = dup
    first = cp.shift
    cp.map{ |arg| arg.gsub " ", "\\ " }.unshift(first) * " "
  end
end

class Pathname
  def subdirs
    children.select { |child| child.directory? }
  end

  def resolved_path
    self.symlink? ? dirname+readlink : self
  end

  def /(other)
    self + other.to_s
  end

  def pretty_print
    if self.symlink?
      puts to_s + " -> " + resolved_path.to_s
    elsif self.directory?
      puts to_s + "/"
    else
      puts to_s
    end
  end
end

def ohai *args
  puts "#{Tty.blue}==>#{Tty.white} #{args.shell_s}#{Tty.reset}"
end

def warn warning
  puts "#{Tty.red}Warning#{Tty.reset}: #{warning.chomp}"
end

def system *args
  warn "Failed during: #{args.shell_s}" unless Kernel.system(*args)
end

####################################################################### script

$HOMEBREW_PREFIX_CANDIDATES=[]

OptionParser.new do |opts|
  opts.banner = "Homebrew Uninstaller\nUsage: ./uninstall [options]"
  opts.summary_width = 16
  opts.on("-pPATH", "--path=PATH", "Manually set path to Homebrew.") { |p| $HOMEBREW_PREFIX_CANDIDATES << Pathname.new(p) }
  opts.on("--skip-cache-log", "Skipes removal of Caches and Logs files.") { |p| options[:skip_cache_log] = true }
  opts.on("-f", "--force", "Forces removal of files, bypassing prompt. USE WITH CAUTION!") { options[:force] = true }
  opts.on("-q", "--quiet", "Suppress all output.") { options[:quiet] = true }
  opts.on("-d", "--dry-run", "Dry run, print results, but perform no actual operations.") { options[:dry_run] = true }
  opts.on_tail("-h", "--help", "Display this message.") { puts opts; exit }
end.parse!

if $HOMEBREW_PREFIX_CANDIDATES.empty? # Attempt to locate Homebrew unless `--path` is passed
  p = `brew --prefix` rescue ""
  $HOMEBREW_PREFIX_CANDIDATES << Pathname.new(p.strip) unless p.empty?
  p = `command -v brew`
  $HOMEBREW_PREFIX_CANDIDATES << Pathname.new(p.strip).parent.parent unless p.empty?
  $HOMEBREW_PREFIX_CANDIDATES << Pathname.new("/usr/local") # Homebrew default path
  $HOMEBREW_PREFIX_CANDIDATES << Pathname.new("#{ENV["HOME"]}/.linuxbrew") # Linuxbrew default path
end

$HOMEBREW_PREFIX = $HOMEBREW_PREFIX_CANDIDATES.detect do |p|
  p.directory? && (p/"Library/Homebrew").directory?
end

abort "Failed to locate Homebrew" if $HOMEBREW_PREFIX.nil?

$HOMEBREW_FILES = %W[
  .git .gitignore .yardopts CODEOFCONDUCT.md CONTRIBUTING.md
  LICENSE.txt README.md SUPPORTERS.md Cellar Library/.rubocop.yml
  Library/Aliases Library/Contributions Library/ENV Library/Formula
  Library/Homebrew Library/LinkedKegs Library/Taps Library/brew.rb
  bin/brew share/doc/homebrew share/man/man1/brew.1
].map { |p| $HOMEBREW_PREFIX/p }

unless options[:skip_cache_log]
  $HOMEBREW_FILES += %W[
    #{ENV["HOME"]}/Library/Caches/Homebrew
    #{ENV["HOME"]}/Library/Logs/Homebrew
    /Library/Caches/Homebrew
    #{ENV["HOME"]}/.cache/Homebrew
  ].map { |p| Pathname.new(p) }
end

if /darwin/i === RUBY_PLATFORM
  $HOMEBREW_FILES += %W[
    /Applications
    #{ENV["HOME"]}/Applications
  ].map do |p|
    Pathname.new(p).subdirs.select do |app|
      app.resolved_path.to_s.start_with? $HOMEBREW_PREFIX.to_s
    end
  end.flatten
end

$HOMEBREW_FILES.select!(&:exist?)

unless options[:quiet]
  warn "This script #{options[:dry_run] ? "would" : "will"} remove:"
  $HOMEBREW_FILES.each(&:pretty_print)
end

unless options[:force] || options[:dry_run]
  STDERR.print "Confirm to uninstall Homebrew? [y/N] "
  abort unless gets.rstrip =~ /y|yes/i
end

ohai "Unlink Homebrew Installation..." unless options[:quiet]
paths = %W[Frameworks bin etc include lib opt sbin share var].
  map { |p| $HOMEBREW_PREFIX/p }.select(&:exist?)
args = %W[-E] + paths.map(&:to_s) + %W[-regex .*/info/([^.][^/]*\.info|dir)]
if options[:dry_run]
  args << "-print"
else
  args += %W[-exec /bin/bash -c]
  args << "/usr/bin/install-info --delete --quiet {} \"$(dirname {})/dir\""
  args << ";"
end
puts "Would uninfo:" if options[:dry_run]
system "/usr/bin/find", *args
args = paths.map(&:to_s) + %W[-type l -lname */Cellar/*]
if options[:dry_run]
  args << "-print"
else
  args += %W[-exec unlink {} ;]
end
puts "Would unlink:" if options[:dry_run]
system "/usr/bin/find", *args
args = paths.map(&:to_s) + %W[-name .DS_Store]
if options[:dry_run]
  args << "-print"
else
  args << "-delete"
end
puts "Would delete:" if options[:dry_run]
system "/usr/bin/find", *args
args = paths.map(&:to_s) + %W[-depth -type d -empty]
if options[:dry_run]
  args << "-print"
else
  args += %W[-exec rmdir {} +]
end
puts "Would remove directories:" if options[:dry_run]
system "/usr/bin/find", *args

ohai "Delete Homebrew Installation..." unless options[:quiet]
$HOMEBREW_FILES.each do |file|
  if options[:dry_run]
    puts "Would remove #{file}"
    next
  end

  if file.symlink?
    system "unlink", file.to_s
  elsif file.file?
    system "rm", file.to_s
  elsif file.directory?
    system "rm", "-rf", file.to_s
  end
end

ohai "Cleanup..." unless options[:quiet]
args = %W[#{$HOMEBREW_PREFIX} -depth -type d -empty]
if options[:dry_run]
  args << "-print"
else
  args += %W[-exec rmdir {} +]
end
puts "Would remove directories:" if options[:dry_run]
system "/usr/bin/find", *args

if $HOMEBREW_PREFIX.exist? && (subdirs = $HOMEBREW_PREFIX.subdirs; !subdirs.empty?) && !options[:quiet]
  puts "Following residual files found:"
  subdirs.each(&:pretty_print)
  puts "You may consider to remove it by yourself."
end

if /darwin/i === RUBY_PLATFORM && $HOMEBREW_PREFIX.to_s == "/usr/local" && !options[:quiet]
  puts <<-EOS
You may consider to restore /usr/local to its original ownership.
  sudo chmod 0755 /usr/local
  sudo chgrp wheel /usr/local
EOS
end
